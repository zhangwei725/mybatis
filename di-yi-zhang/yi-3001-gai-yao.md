# 概要

## 一、为什么要学习Mybaits

### 1、传统的JDBC查询数据一般有以下七个步骤

1. 加载JDBC驱动；
2. 建立并获取数据库连接；
3. 创建 JDBC Statements 对象；
4. 设置SQL语句的传入参数；
5. 执行SQL语句并获得查询结果；
6. 对查询结果进行转换处理并将处理结果返回；
7. 释放相关资源（关闭Connection，关闭Statement，关闭ResultSet）；

### 2、传统的JDBC操作的缺点与优化方案

#### 2.1、建立连接与释放资源

1. 问题描述

   ```
   传统的JDBC连接数据频繁的开启和关闭对资源造成浪费,影响系统的性能
   ```

2. 解决方案

   ```
   使用数据库连接池来解决资源浪费的问题。
   通过连接池就可以反复利用已经建立的连接去访问数据库了。减少连接的开启和关闭的时间。
   例如:druid,c3p0
   ```

#### 2.2、SQL语句统一管理

1. 问题描述

   ```
   使用传统的JDBC,DAO里充斥着各种SQL语句这样会造成以下几个问题
   1.需求一旦发生改变,维护起来相当麻烦,
   2.可读性比较差
   3.不利于在客服端调试
   ```

2. 解决方案

   ```
   提供统一的存放位置,例如我们可以把SQL语句统一集中放到配置文件或者数据库里面（以key-value的格式存放）
   ```

#### 2.3、SQL语句参数问题

1. 问题描述

   ```
   如果是JDBC操作我们可以通过SQL语句设置占位符来使用传入参数，
   但是本身也存在一定的局限性。
   1. 传入参数必须按着顺序传入。
   2. 如果传入参数不规定,有时候我们参数是2个或者三个。
   3. 传入的字段名不一样。
   ```

2. 解决方案

   ```
   我们先解决这个动态问题，按照我们正常的程序员思维是，通过if和else这类的判断来进行是最直观的，这个时候我们想到了JSTL中的<if test=””></if>这样的标签，那么，能不能将这类的标签引入到SQL语句中呢？假设可以，那么我们这里就需要一个专门的SQL解析器来解析这样的SQL语句，但是，if判断的变量来自于哪里呢？传入的值本身是可变的，那么我们得为这个值定义一个不变的变量名称，而且这个变量名称必须和对应的值要有对应关系，可以通过这个变量名称找到对应的值，这个时候我们想到了key-value的Map。解析的时候根据变量名的具体值来判断。

   假如前面可以判断没有问题，那么假如判断的结果是true，那么就需要输出的标签里面的SQL片段，但是怎么解决在标签里面使用变量名称的问题呢？这里我们需要使用一种有别于SQL的语法来嵌入变量（比如使用＃变量名＃）。这样，SQL语句经过解析后就可以动态的生成符合上下文的SQL语句。

   还有，怎么区分开占位符变量和非占位变量？有时候我们单单使用占位符是满足不了的，占位符只能为查询条件占位，SQL语句其他地方使用不了。这里我们可以使用#变量名#表示占位符变量，使用$变量名$表示非占位符变量。
   ```

#### 2.4、结果映射和结果缓存

1. 问题描述

   ```
   执行SQL语句、获取执行结果、对执行结果进行转换处理、释放相关资源是一整套下来的。假如是执行查询语句，那么执行SQL语句后，返回的是一个ResultSet结果集，这个时候我们就需要将ResultSet对象的数据取出来，不然等到释放资源时就取不到这些结果信息了。我们从前面的优化来看，以及将获取连接、设置传入参数、执行SQL语句、释放资源这些都封装起来了，只剩下结果处理这块还没有进行封装，如果能封装起来，每个数据库操作都不用自己写那么一大堆Java代码，直接调用一个封装的方法就可以搞定
   ```

2. 解决方案

   ```
   一般对执行结果的有哪些处理，有可能将结果不做任何处理就直接返回，也有可能将结果转换成一个JavaBean对象返回、一个Map返回、一个List返回等`，结果处理可能是多种多样的。从这里看，我们必须告诉SQL处理器两点：第一，需要返回什么类型的对象；第二，需要返回的对象的数据结构怎么跟执行的结果映射，这样才能将具体的值copy到对应的数据结构上。
   接下来，我们可以进而考虑对SQL执行结果的缓存来提升性能。缓存数据都是key-value的格式，那么这个key怎么来呢？怎么保证唯一呢？即使同一条SQL语句几次访问的过程中由于传入参数的不同，得到的执行SQL语句也是不同的。那么缓存起来的时候是多对。但是SQL语句和传入参数两部分合起来可以作为数据缓存的key值。
   ```

#### 2.5、解决重复SQL语句问题

1. 问题描述

   ```
   由于我们将所有SQL语句都放到配置文件中，这个时候会遇到一个SQL重复的问题，几个功能的SQL语句其实都差不多，有些可能是SELECT后面那段不同、有些可能是WHERE语句不同。有时候表结构改了，那么我们就需要改多个地方，不利于维护
   ```

2. 解决方案

   ```
   当我们的代码程序出现重复代码时怎么办？将重复的代码抽离出来成为独立的一个类，然后在各个需要使用的地方进行引用。对于SQL重复的问题，我们也可以采用这种方式，通过将SQL片段模块化，将重复的SQL片段独立成一个SQL块，然后在各个SQL语句引用重复的SQL块，这样需要修改时只需要修改一处即可。
   ```

## 二、MyBatis框架整体设计

### 1、结构图

1. 接口层与数据处理层

   ![](http://opzv089nq.bkt.clouddn.com/17-8-25/99345356.jpg)

2. 框架支持层与引导层

   ![](http://opzv089nq.bkt.clouddn.com/17-8-25/76446552.jpg)

## 三、接口层

### 1、主要作用

​	提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理

1. 使用传统的MyBatis提供的API；
2. 使用Mapper接口；

### 2、MyBatis提供的API

1. 说明

   ```
   传统的传递Statement Id 和查询参数给 SqlSession 对象，使用 SqlSession对象完成和数据库的交互；
   MyBatis提供了非常方便和简单的API，供用户实现对数据库的增删改查数据操作，以及对数据库连接信息和MyBatis 自身配置信息的维护操作
   ```

2. 语法格式

   ```

   ```

### 3、使用Mapper接口

## 四、数据处理层

### 4.1、主要作用

​	负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。

它主要的目的是根据调用的请求完成一次数据库操作,主要完成以下两个功能

1. 通过传入参数构建动态SQL语句；
2. SQL语句的执行以及封装查询结果集成List<E>；

### 4.2、参数映射和动态SQL语句生成

​      动态语句生成可以说是MyBatis框架非常优雅的一个设计，**MyBatis**通过传入的参数值，使用**Ognl** 来动态地构造SQL语句，使得**MyBatis**有很强的灵活性和扩展性。参数映射指的是对于**Java**数据类型和**jdbc**数据类型之间的转换：这里有包括两个过程：查询阶段，我们要将java类型的数据，转换成**jdbc**类型的数据，通过preparedStatement.setXXX()来设值；另一个就是对**resultset**查询结果集的**jdbcType**数据转换成**java**数据类型。

### 4.3、SQL语句的执行以及封装查询结果集成List<E>

​	动态SQL语句生成之后，**MyBatis**将执行SQL语句，并将可能返回的结果集转换成**List<E>** 列表。**MyBatis**在对结果集的处理中，支持结果集关系一对多和多对一的转换，并且有两种支持方式，一种为嵌套查询语句的查询，还有一种是嵌套结果集的查询。

## 五、框架支撑层

5.1、主要作用

​	负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。

### 5.1、事务管理机制

> 事务管理机制对于**ORM**框架而言是不可缺少的一部分，事务管理机制的质量也是考量一个**ORM**框架是否优秀的一个标准

### 5.2、连接池管理机制

> 由于创建一个数据库连接所占用的资源比较大， 对于数据吞吐量大和访问量非常大的应用而言，连接池的设计就显得非常重要

### 5.3、缓存机制

> 为了提高数据利用率和减小服务器和数据库的压力，**MyBatis**会对于一些查询提供会话级别的数据缓存，会将对某一次查询，放置到**SqlSession**中，在允许的时间间隔内，对于完全相同的查询，**MyBatis**会直接将缓存结果返回给用户，而不用再到数据库中查找。

### 5.4、SQL语句的配置方式

> 传统的**MyBatis**配置**SQL**语句方式就是使用XML文件进行配置的，但是这种方式不能很好地支持面向接口编程的理念，为了支持面向接口的编程，**MyBatis**引入了**Mapper**接口的概念，面向接口的引入，对使用注解来配置**SQL**语句成为可能，用户只需要在接口上添加必要的注解即可，不用再去配置**XML**文件了，但是，目前的**MyBatis**只是对注解配置**SQL**语句提供了有限的支持，某些高级功能还是要依赖**XML**配置文件配置**SQL**语句。

## 六、引导层

### 6.1、主要作用

>  引导层是配置和启动MyBatis配置信息的方式,主要提供两种方式来引导MyBatis
>
> 1. 基于XML配置文件：基于XML配置文件的方式是将MyBatis的所有配置信息放在XML文件中，MyBatis通过加载并XML配置文件，将配置文信息组装成内部的Configuration对象。
> 2. 基于Java API：这种方式不使用XML配置文件，需要MyBatis使用者在Java代码中，手动创建Configuration对象，然后将配置参数set 进入Configuration对象中。

### 6.2、使用XML配置MyBatis

#### 2.1、完整结构

> ```
> <!-- 配置文件的根元素 -->  
> <configuration>  
>  <!-- 属性：定义外部配置 -->  
>   <properties></properties>  
>   <!-- 设置：定义mybatis的一些全局性设置 -->  
>   <settings>  
>      <!-- 具体的参数名和参数值 -->  
>      <setting name="" value=""/>   
>   </settings>  
>   <!-- 类型名称：为一些类定义别名 -->  
>   <typeAliases></typeAliases>  
>   <!-- 类型处理器：定义Java类型与数据库中的数据类型之间的转换关系 -->  
>   <typeHandlers></typeHandlers>  
>   <!-- 对象工厂 -->  
>   <objectFactory type=""></objectFactory>  
>   <!-- 插件：mybatis的插件,插件可以修改mybatis的内部运行规则 -->  
>   <plugins>  
>      <plugin interceptor=""></plugin>  
>   </plugins>  
>   <!-- 环境：配置mybatis的环境(核心) -->  
>   <environments default="">  
>      <!-- 环境变量：可以配置多个环境变量，比如使用多数据源时，就需要配置多个环境变量 -->  
>      <environment id="">  
>         <!-- 事务管理器 -->  
>         <transactionManager type=""></transactionManager>  
>         <!-- 数据源 -->  
>         <dataSource type=""></dataSource>  
>      </environment>   
>   </environments>  
>   <!-- 数据库厂商标识 -->  
>   <databaseIdProvider type=""></databaseIdProvider>  
>   <!-- 映射器：指定映射文件或者映射类 -->  
>   <mappers></mappers>  
> </configuration>  
> ```

#### 2.2、配置环境environments(核心配置)

> MyBatis可以配置成适应多种环境，这种机制有助于将sql映射应用于多种数据库中，现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同的Schema的多个生产数据库，想使用相同的sql映射。许多类似的用例。
>
> 尽管可以配置多个环境，但是每个SqlSessionFactory实例只能选择其一。
> 所以，如果想连接两个数据库，就需要创建两个SqlSessionFactory实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推



#### 2.3、数据源(DataSource)

> MyBatis支持三种内建的DataSource类型: UNPOOLED, POOLED, 和JNDI.
>
> 1. UNPOOLED类型的数据源dataSource为每一个用户请求创建一个数据库连接。在多用户并发应用中，不建议使用。
> 2. POOLED类型的数据源dataSource创建了一个数据库连接池，对用户的每一个请求，会使用缓冲池中的一个可用的Connection对象，这样可以提高应用的性能。MyBatis提供了org.apache.ibatis.datasource.pooled.PooledDataSource 实现javax.sql.DataSource来创建连接池。
> 3. JNDI类型的数据源dataSource使用了应用服务器的数据库连接池，并且使用JNDI查找来获取数据库连接。

#### 2.4、事务工厂(TransactionFactory)

> MyBatis支持一下两种TransactionFactory实现
>
> 1. JdbcTransactionFactory
> 2. ManagedTransactionFactory

#### 2.5、映射器(Mappers)

> MyBatis提供了一些使用Configuration对象注册Mapper XML文件和Mappe接口的方法
>
> 1. 添加一个Mapper接口
>
>    ```
>    configuration.addMapper(XxxMapper.class);  
>    ```
>
> 2. 添加 com.mybatis3.mappers包中的所有Mapper XML文件或者Mapper接口
>
>    ```
>    configuration.addMappers("com.mybatis3.mappers");  
>    ```
>
> 3. 添加所有com.mybatis3.mappers包中的拓展了特定Mapper接口的Maper接口